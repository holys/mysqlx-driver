// Code generated by protoc-gen-go.
// source: mysqlx_datatypes.proto
// DO NOT EDIT!

/*
Package Mysqlx_Datatypes is a generated protocol buffer package.

It is generated from these files:
	mysqlx_datatypes.proto

It has these top-level messages:
	Scalar
	Object
	Array
	Any
*/
package Mysqlx_Datatypes

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
const _ = proto.ProtoPackageIsVersion1

type Scalar_Type int32

const (
	Scalar_V_SINT   Scalar_Type = 1
	Scalar_V_UINT   Scalar_Type = 2
	Scalar_V_NULL   Scalar_Type = 3
	Scalar_V_OCTETS Scalar_Type = 4
	Scalar_V_DOUBLE Scalar_Type = 5
	Scalar_V_FLOAT  Scalar_Type = 6
	Scalar_V_BOOL   Scalar_Type = 7
	Scalar_V_STRING Scalar_Type = 8
)

var Scalar_Type_name = map[int32]string{
	1: "V_SINT",
	2: "V_UINT",
	3: "V_NULL",
	4: "V_OCTETS",
	5: "V_DOUBLE",
	6: "V_FLOAT",
	7: "V_BOOL",
	8: "V_STRING",
}
var Scalar_Type_value = map[string]int32{
	"V_SINT":   1,
	"V_UINT":   2,
	"V_NULL":   3,
	"V_OCTETS": 4,
	"V_DOUBLE": 5,
	"V_FLOAT":  6,
	"V_BOOL":   7,
	"V_STRING": 8,
}

func (x Scalar_Type) Enum() *Scalar_Type {
	p := new(Scalar_Type)
	*p = x
	return p
}
func (x Scalar_Type) String() string {
	return proto.EnumName(Scalar_Type_name, int32(x))
}
func (x *Scalar_Type) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Scalar_Type_value, data, "Scalar_Type")
	if err != nil {
		return err
	}
	*x = Scalar_Type(value)
	return nil
}
func (Scalar_Type) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0, 0} }

type Any_Type int32

const (
	Any_SCALAR Any_Type = 1
	Any_OBJECT Any_Type = 2
	Any_ARRAY  Any_Type = 3
)

var Any_Type_name = map[int32]string{
	1: "SCALAR",
	2: "OBJECT",
	3: "ARRAY",
}
var Any_Type_value = map[string]int32{
	"SCALAR": 1,
	"OBJECT": 2,
	"ARRAY":  3,
}

func (x Any_Type) Enum() *Any_Type {
	p := new(Any_Type)
	*p = x
	return p
}
func (x Any_Type) String() string {
	return proto.EnumName(Any_Type_name, int32(x))
}
func (x *Any_Type) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Any_Type_value, data, "Any_Type")
	if err != nil {
		return err
	}
	*x = Any_Type(value)
	return nil
}
func (Any_Type) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{3, 0} }

// a scalar
type Scalar struct {
	Type         *Scalar_Type `protobuf:"varint,1,req,name=type,enum=Mysqlx.Datatypes.Scalar_Type" json:"type,omitempty"`
	VSignedInt   *int64       `protobuf:"zigzag64,2,opt,name=v_signed_int" json:"v_signed_int,omitempty"`
	VUnsignedInt *uint64      `protobuf:"varint,3,opt,name=v_unsigned_int" json:"v_unsigned_int,omitempty"`
	// 4 is unused, was Null which doesn't have a storage anymore
	VOctets          *Scalar_Octets `protobuf:"bytes,5,opt,name=v_octets" json:"v_octets,omitempty"`
	VDouble          *float64       `protobuf:"fixed64,6,opt,name=v_double" json:"v_double,omitempty"`
	VFloat           *float32       `protobuf:"fixed32,7,opt,name=v_float" json:"v_float,omitempty"`
	VBool            *bool          `protobuf:"varint,8,opt,name=v_bool" json:"v_bool,omitempty"`
	VString          *Scalar_String `protobuf:"bytes,9,opt,name=v_string" json:"v_string,omitempty"`
	XXX_unrecognized []byte         `json:"-"`
}

func (m *Scalar) Reset()                    { *m = Scalar{} }
func (m *Scalar) String() string            { return proto.CompactTextString(m) }
func (*Scalar) ProtoMessage()               {}
func (*Scalar) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *Scalar) GetType() Scalar_Type {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return Scalar_V_SINT
}

func (m *Scalar) GetVSignedInt() int64 {
	if m != nil && m.VSignedInt != nil {
		return *m.VSignedInt
	}
	return 0
}

func (m *Scalar) GetVUnsignedInt() uint64 {
	if m != nil && m.VUnsignedInt != nil {
		return *m.VUnsignedInt
	}
	return 0
}

func (m *Scalar) GetVOctets() *Scalar_Octets {
	if m != nil {
		return m.VOctets
	}
	return nil
}

func (m *Scalar) GetVDouble() float64 {
	if m != nil && m.VDouble != nil {
		return *m.VDouble
	}
	return 0
}

func (m *Scalar) GetVFloat() float32 {
	if m != nil && m.VFloat != nil {
		return *m.VFloat
	}
	return 0
}

func (m *Scalar) GetVBool() bool {
	if m != nil && m.VBool != nil {
		return *m.VBool
	}
	return false
}

func (m *Scalar) GetVString() *Scalar_String {
	if m != nil {
		return m.VString
	}
	return nil
}

// a string with a charset/collation
type Scalar_String struct {
	Value            []byte  `protobuf:"bytes,1,req,name=value" json:"value,omitempty"`
	Collation        *uint64 `protobuf:"varint,2,opt,name=collation" json:"collation,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Scalar_String) Reset()                    { *m = Scalar_String{} }
func (m *Scalar_String) String() string            { return proto.CompactTextString(m) }
func (*Scalar_String) ProtoMessage()               {}
func (*Scalar_String) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0, 0} }

func (m *Scalar_String) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *Scalar_String) GetCollation() uint64 {
	if m != nil && m.Collation != nil {
		return *m.Collation
	}
	return 0
}

// an opaque octet sequence, with an optional content_type
// See ``Mysqlx.Resultset.ColumnMetadata`` for list of known values.
type Scalar_Octets struct {
	Value            []byte  `protobuf:"bytes,1,req,name=value" json:"value,omitempty"`
	ContentType      *uint32 `protobuf:"varint,2,opt,name=content_type" json:"content_type,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Scalar_Octets) Reset()                    { *m = Scalar_Octets{} }
func (m *Scalar_Octets) String() string            { return proto.CompactTextString(m) }
func (*Scalar_Octets) ProtoMessage()               {}
func (*Scalar_Octets) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0, 1} }

func (m *Scalar_Octets) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *Scalar_Octets) GetContentType() uint32 {
	if m != nil && m.ContentType != nil {
		return *m.ContentType
	}
	return 0
}

// a object
type Object struct {
	Fld              []*Object_ObjectField `protobuf:"bytes,1,rep,name=fld" json:"fld,omitempty"`
	XXX_unrecognized []byte                `json:"-"`
}

func (m *Object) Reset()                    { *m = Object{} }
func (m *Object) String() string            { return proto.CompactTextString(m) }
func (*Object) ProtoMessage()               {}
func (*Object) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *Object) GetFld() []*Object_ObjectField {
	if m != nil {
		return m.Fld
	}
	return nil
}

type Object_ObjectField struct {
	Key              *string `protobuf:"bytes,1,req,name=key" json:"key,omitempty"`
	Value            *Any    `protobuf:"bytes,2,req,name=value" json:"value,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Object_ObjectField) Reset()                    { *m = Object_ObjectField{} }
func (m *Object_ObjectField) String() string            { return proto.CompactTextString(m) }
func (*Object_ObjectField) ProtoMessage()               {}
func (*Object_ObjectField) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1, 0} }

func (m *Object_ObjectField) GetKey() string {
	if m != nil && m.Key != nil {
		return *m.Key
	}
	return ""
}

func (m *Object_ObjectField) GetValue() *Any {
	if m != nil {
		return m.Value
	}
	return nil
}

// a Array
type Array struct {
	Value            []*Any `protobuf:"bytes,1,rep,name=value" json:"value,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *Array) Reset()                    { *m = Array{} }
func (m *Array) String() string            { return proto.CompactTextString(m) }
func (*Array) ProtoMessage()               {}
func (*Array) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *Array) GetValue() []*Any {
	if m != nil {
		return m.Value
	}
	return nil
}

// a helper to allow all field types
type Any struct {
	Type             *Any_Type `protobuf:"varint,1,req,name=type,enum=Mysqlx.Datatypes.Any_Type" json:"type,omitempty"`
	Scalar           *Scalar   `protobuf:"bytes,2,opt,name=scalar" json:"scalar,omitempty"`
	Obj              *Object   `protobuf:"bytes,3,opt,name=obj" json:"obj,omitempty"`
	Array            *Array    `protobuf:"bytes,4,opt,name=array" json:"array,omitempty"`
	XXX_unrecognized []byte    `json:"-"`
}

func (m *Any) Reset()                    { *m = Any{} }
func (m *Any) String() string            { return proto.CompactTextString(m) }
func (*Any) ProtoMessage()               {}
func (*Any) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *Any) GetType() Any_Type {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return Any_SCALAR
}

func (m *Any) GetScalar() *Scalar {
	if m != nil {
		return m.Scalar
	}
	return nil
}

func (m *Any) GetObj() *Object {
	if m != nil {
		return m.Obj
	}
	return nil
}

func (m *Any) GetArray() *Array {
	if m != nil {
		return m.Array
	}
	return nil
}

func init() {
	proto.RegisterType((*Scalar)(nil), "Mysqlx.Datatypes.Scalar")
	proto.RegisterType((*Scalar_String)(nil), "Mysqlx.Datatypes.Scalar.String")
	proto.RegisterType((*Scalar_Octets)(nil), "Mysqlx.Datatypes.Scalar.Octets")
	proto.RegisterType((*Object)(nil), "Mysqlx.Datatypes.Object")
	proto.RegisterType((*Object_ObjectField)(nil), "Mysqlx.Datatypes.Object.ObjectField")
	proto.RegisterType((*Array)(nil), "Mysqlx.Datatypes.Array")
	proto.RegisterType((*Any)(nil), "Mysqlx.Datatypes.Any")
	proto.RegisterEnum("Mysqlx.Datatypes.Scalar_Type", Scalar_Type_name, Scalar_Type_value)
	proto.RegisterEnum("Mysqlx.Datatypes.Any_Type", Any_Type_name, Any_Type_value)
}

var fileDescriptor0 = []byte{
	// 514 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x84, 0x93, 0x6f, 0x6f, 0xda, 0x30,
	0x10, 0xc6, 0x05, 0x09, 0x01, 0x0e, 0xca, 0x3c, 0x6b, 0xeb, 0x22, 0xb4, 0x3f, 0x15, 0xea, 0x26,
	0xb6, 0xa9, 0x91, 0xc6, 0x27, 0x58, 0xa0, 0x74, 0xea, 0x94, 0x11, 0x89, 0x04, 0xa4, 0xbd, 0xb2,
	0x42, 0x08, 0x55, 0x98, 0x89, 0xbb, 0xc4, 0x44, 0xcd, 0x8b, 0x7d, 0xbd, 0x7d, 0x81, 0x7d, 0xa1,
	0x39, 0x36, 0x55, 0xbb, 0x16, 0xb4, 0x57, 0xb9, 0x7b, 0xf2, 0x73, 0xee, 0xee, 0x39, 0x07, 0x8e,
	0x37, 0x45, 0xf6, 0x93, 0xde, 0x90, 0x65, 0xc0, 0x03, 0x5e, 0x5c, 0x47, 0x99, 0x75, 0x9d, 0x32,
	0xce, 0x30, 0xfa, 0x26, 0x75, 0xeb, 0xfc, 0x56, 0xef, 0xfd, 0xd6, 0xc0, 0xf0, 0xc2, 0x80, 0x06,
	0x29, 0xfe, 0x08, 0x7a, 0xa9, 0x99, 0x95, 0x93, 0x6a, 0xbf, 0x33, 0x78, 0x65, 0x3d, 0x64, 0x2d,
	0xc5, 0x59, 0xbe, 0x48, 0xf0, 0x33, 0x68, 0xe7, 0x24, 0x8b, 0xaf, 0x92, 0x68, 0x49, 0xe2, 0x84,
	0x9b, 0xd5, 0x93, 0x4a, 0x1f, 0xe3, 0x63, 0xe8, 0xe4, 0x64, 0x9b, 0xdc, 0xd3, 0x35, 0xa1, 0xeb,
	0xf8, 0x13, 0x34, 0x72, 0xc2, 0x42, 0x1e, 0xf1, 0xcc, 0xac, 0x09, 0xa5, 0x35, 0x78, 0x73, 0xf0,
	0xf3, 0xae, 0xc4, 0x30, 0x2a, 0x8f, 0x2c, 0xd9, 0x76, 0x41, 0x23, 0xd3, 0x10, 0x47, 0x2a, 0xf8,
	0x09, 0xd4, 0x73, 0xb2, 0xa2, 0x2c, 0xe0, 0x66, 0x5d, 0x08, 0x55, 0xdc, 0x01, 0x23, 0x27, 0x0b,
	0xc6, 0xa8, 0xd9, 0x10, 0x79, 0x43, 0x55, 0xc9, 0x78, 0x1a, 0x27, 0x57, 0x66, 0xf3, 0x3f, 0x55,
	0x3c, 0x89, 0x75, 0x3f, 0x88, 0xe9, 0x65, 0x84, 0x8f, 0xa0, 0x96, 0x07, 0x74, 0xab, 0xc6, 0x6f,
	0xe3, 0xa7, 0xd0, 0x0c, 0x19, 0xa5, 0x01, 0x8f, 0x59, 0x22, 0x87, 0xd3, 0xbb, 0x67, 0x60, 0xec,
	0x7a, 0x7b, 0xc0, 0x0a, 0x2f, 0x42, 0x96, 0xf0, 0x28, 0xe1, 0x44, 0x1a, 0x58, 0xe2, 0x47, 0xbd,
	0x0d, 0xe8, 0xd2, 0x29, 0x00, 0x63, 0x4e, 0xbc, 0xcb, 0x89, 0x8f, 0x2a, 0x2a, 0x9e, 0x95, 0x71,
	0x55, 0xc5, 0x93, 0x99, 0xe3, 0x20, 0x0d, 0xb7, 0xa1, 0x31, 0x27, 0xee, 0xc8, 0x1f, 0xfb, 0x1e,
	0xd2, 0x55, 0x76, 0xee, 0xce, 0x86, 0xce, 0x18, 0xd5, 0x70, 0x0b, 0xea, 0x73, 0x72, 0xe1, 0xb8,
	0xb6, 0x8f, 0x0c, 0x75, 0x68, 0xe8, 0xba, 0x0e, 0xaa, 0x2b, 0xcc, 0xf3, 0xa7, 0x97, 0x93, 0x2f,
	0xa8, 0xd1, 0xfb, 0x25, 0xba, 0x5b, 0xac, 0xa3, 0x90, 0x0b, 0x1b, 0xb4, 0x15, 0x5d, 0x8a, 0xde,
	0x34, 0xe1, 0xc0, 0xe9, 0x63, 0x07, 0x14, 0xb6, 0x7b, 0x5c, 0xc4, 0x11, 0x5d, 0x76, 0x3f, 0x43,
	0xeb, 0x5e, 0x2a, 0x4a, 0x6a, 0x3f, 0xa2, 0x42, 0x4e, 0xd7, 0xc4, 0xa7, 0xb7, 0xc3, 0x56, 0x45,
	0xda, 0x1a, 0x3c, 0x7f, 0xfc, 0x41, 0x3b, 0x29, 0x7a, 0x67, 0x50, 0xb3, 0xd3, 0x34, 0x28, 0xee,
	0x70, 0x55, 0xff, 0x00, 0xfe, 0xa7, 0x02, 0x9a, 0x78, 0xe2, 0xfe, 0x3f, 0x77, 0xae, 0xbb, 0x17,
	0x56, 0x17, 0xae, 0x0f, 0x46, 0x26, 0x57, 0x27, 0xed, 0x6d, 0x0d, 0xcc, 0x43, 0xab, 0xc5, 0x6f,
	0x41, 0x63, 0x8b, 0xb5, 0xbc, 0x79, 0x7b, 0xb1, 0x9d, 0x4d, 0xef, 0xa0, 0x16, 0x94, 0x1d, 0x9b,
	0xba, 0x04, 0x5f, 0xec, 0xa9, 0x5d, 0xbe, 0xee, 0xbd, 0xbf, 0xdb, 0xa3, 0x37, 0xb2, 0x1d, 0x7b,
	0xaa, 0xf6, 0xe8, 0x0e, 0xbf, 0x8e, 0x47, 0xe5, 0x1e, 0x9b, 0x62, 0xf2, 0xe9, 0xd4, 0xfe, 0x8e,
	0xb4, 0xe1, 0x6b, 0x78, 0x19, 0xb2, 0x8d, 0x25, 0x7f, 0x3e, 0x2b, 0x5c, 0xab, 0xe0, 0x46, 0xfd,
	0x7b, 0x8b, 0xed, 0xea, 0x6f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x77, 0xb9, 0x93, 0xed, 0x97, 0x03,
	0x00, 0x00,
}
