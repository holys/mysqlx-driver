// Code generated by protoc-gen-go.
// source: mysqlx_crud.proto
// DO NOT EDIT!

/*
Package Mysqlx_Crud is a generated protocol buffer package.

Basic CRUD operations

It is generated from these files:
	mysqlx_crud.proto

It has these top-level messages:
	Column
	Projection
	Collection
	Limit
	Order
	UpdateOperation
	Find
	Insert
	Update
	Delete
*/
package Mysqlx_Crud

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import "github.com/sjmudd/mysql/plugin/x/Mysqlx_Expr"
import "github.com/sjmudd/mysql/plugin/x/Mysqlx_Datatypes"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
const _ = proto.ProtoPackageIsVersion1

// DataModel to use for filters, names, ...
type DataModel int32

const (
	DataModel_DOCUMENT DataModel = 1
	DataModel_TABLE    DataModel = 2
)

var DataModel_name = map[int32]string{
	1: "DOCUMENT",
	2: "TABLE",
}
var DataModel_value = map[string]int32{
	"DOCUMENT": 1,
	"TABLE":    2,
}

func (x DataModel) Enum() *DataModel {
	p := new(DataModel)
	*p = x
	return p
}
func (x DataModel) String() string {
	return proto.EnumName(DataModel_name, int32(x))
}
func (x *DataModel) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(DataModel_value, data, "DataModel")
	if err != nil {
		return err
	}
	*x = DataModel(value)
	return nil
}
func (DataModel) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type Order_Direction int32

const (
	Order_ASC  Order_Direction = 1
	Order_DESC Order_Direction = 2
)

var Order_Direction_name = map[int32]string{
	1: "ASC",
	2: "DESC",
}
var Order_Direction_value = map[string]int32{
	"ASC":  1,
	"DESC": 2,
}

func (x Order_Direction) Enum() *Order_Direction {
	p := new(Order_Direction)
	*p = x
	return p
}
func (x Order_Direction) String() string {
	return proto.EnumName(Order_Direction_name, int32(x))
}
func (x *Order_Direction) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Order_Direction_value, data, "Order_Direction")
	if err != nil {
		return err
	}
	*x = Order_Direction(value)
	return nil
}
func (Order_Direction) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{4, 0} }

type UpdateOperation_UpdateType int32

const (
	UpdateOperation_SET          UpdateOperation_UpdateType = 1
	UpdateOperation_ITEM_REMOVE  UpdateOperation_UpdateType = 2
	UpdateOperation_ITEM_SET     UpdateOperation_UpdateType = 3
	UpdateOperation_ITEM_REPLACE UpdateOperation_UpdateType = 4
	UpdateOperation_ITEM_MERGE   UpdateOperation_UpdateType = 5
	UpdateOperation_ARRAY_INSERT UpdateOperation_UpdateType = 6
	UpdateOperation_ARRAY_APPEND UpdateOperation_UpdateType = 7
)

var UpdateOperation_UpdateType_name = map[int32]string{
	1: "SET",
	2: "ITEM_REMOVE",
	3: "ITEM_SET",
	4: "ITEM_REPLACE",
	5: "ITEM_MERGE",
	6: "ARRAY_INSERT",
	7: "ARRAY_APPEND",
}
var UpdateOperation_UpdateType_value = map[string]int32{
	"SET":          1,
	"ITEM_REMOVE":  2,
	"ITEM_SET":     3,
	"ITEM_REPLACE": 4,
	"ITEM_MERGE":   5,
	"ARRAY_INSERT": 6,
	"ARRAY_APPEND": 7,
}

func (x UpdateOperation_UpdateType) Enum() *UpdateOperation_UpdateType {
	p := new(UpdateOperation_UpdateType)
	*p = x
	return p
}
func (x UpdateOperation_UpdateType) String() string {
	return proto.EnumName(UpdateOperation_UpdateType_name, int32(x))
}
func (x *UpdateOperation_UpdateType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(UpdateOperation_UpdateType_value, data, "UpdateOperation_UpdateType")
	if err != nil {
		return err
	}
	*x = UpdateOperation_UpdateType(value)
	return nil
}
func (UpdateOperation_UpdateType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{5, 0}
}

// column definition
type Column struct {
	Name             *string                         `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Alias            *string                         `protobuf:"bytes,2,opt,name=alias" json:"alias,omitempty"`
	DocumentPath     []*Mysqlx_Expr.DocumentPathItem `protobuf:"bytes,3,rep,name=document_path" json:"document_path,omitempty"`
	XXX_unrecognized []byte                          `json:"-"`
}

func (m *Column) Reset()                    { *m = Column{} }
func (m *Column) String() string            { return proto.CompactTextString(m) }
func (*Column) ProtoMessage()               {}
func (*Column) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *Column) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *Column) GetAlias() string {
	if m != nil && m.Alias != nil {
		return *m.Alias
	}
	return ""
}

func (m *Column) GetDocumentPath() []*Mysqlx_Expr.DocumentPathItem {
	if m != nil {
		return m.DocumentPath
	}
	return nil
}

// a projection
//
// :param source: the expression identifying an element from the source data
//                which can include a column identifier or any expression
// :param alias: optional alias. Required for DOCUMENTs (clients may use
//              the source string as default)
type Projection struct {
	Source           *Mysqlx_Expr.Expr `protobuf:"bytes,1,req,name=source" json:"source,omitempty"`
	Alias            *string           `protobuf:"bytes,2,opt,name=alias" json:"alias,omitempty"`
	XXX_unrecognized []byte            `json:"-"`
}

func (m *Projection) Reset()                    { *m = Projection{} }
func (m *Projection) String() string            { return proto.CompactTextString(m) }
func (*Projection) ProtoMessage()               {}
func (*Projection) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *Projection) GetSource() *Mysqlx_Expr.Expr {
	if m != nil {
		return m.Source
	}
	return nil
}

func (m *Projection) GetAlias() string {
	if m != nil && m.Alias != nil {
		return *m.Alias
	}
	return ""
}

// collection
type Collection struct {
	Name             *string `protobuf:"bytes,1,req,name=name" json:"name,omitempty"`
	Schema           *string `protobuf:"bytes,2,opt,name=schema" json:"schema,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Collection) Reset()                    { *m = Collection{} }
func (m *Collection) String() string            { return proto.CompactTextString(m) }
func (*Collection) ProtoMessage()               {}
func (*Collection) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *Collection) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *Collection) GetSchema() string {
	if m != nil && m.Schema != nil {
		return *m.Schema
	}
	return ""
}

// limit
//
// :param row_count: maximum rows to filter
// :param offset: maximum rows to skip before applying the row_count
type Limit struct {
	RowCount         *uint64 `protobuf:"varint,1,req,name=row_count" json:"row_count,omitempty"`
	Offset           *uint64 `protobuf:"varint,2,opt,name=offset" json:"offset,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Limit) Reset()                    { *m = Limit{} }
func (m *Limit) String() string            { return proto.CompactTextString(m) }
func (*Limit) ProtoMessage()               {}
func (*Limit) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *Limit) GetRowCount() uint64 {
	if m != nil && m.RowCount != nil {
		return *m.RowCount
	}
	return 0
}

func (m *Limit) GetOffset() uint64 {
	if m != nil && m.Offset != nil {
		return *m.Offset
	}
	return 0
}

// sort order
type Order struct {
	Expr             *Mysqlx_Expr.Expr `protobuf:"bytes,1,req,name=expr" json:"expr,omitempty"`
	Direction        *Order_Direction  `protobuf:"varint,2,opt,name=direction,enum=Mysqlx.Crud.Order_Direction,def=1" json:"direction,omitempty"`
	XXX_unrecognized []byte            `json:"-"`
}

func (m *Order) Reset()                    { *m = Order{} }
func (m *Order) String() string            { return proto.CompactTextString(m) }
func (*Order) ProtoMessage()               {}
func (*Order) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

const Default_Order_Direction Order_Direction = Order_ASC

func (m *Order) GetExpr() *Mysqlx_Expr.Expr {
	if m != nil {
		return m.Expr
	}
	return nil
}

func (m *Order) GetDirection() Order_Direction {
	if m != nil && m.Direction != nil {
		return *m.Direction
	}
	return Default_Order_Direction
}

// update operations
//
// :param source: specification of the value to be updated
//      if data_model is TABLE, a column name may be specified and also a document path, if the column has type JSON
//      if data_model is DOCUMENT, only document paths are allowed
//      in both cases, schema and table must be not set
// :param operation: the type of operation to be performed
// :param value: an expression to be computed as the new value for the operation
type UpdateOperation struct {
	Source           *Mysqlx_Expr.ColumnIdentifier `protobuf:"bytes,1,req,name=source" json:"source,omitempty"`
	Operation        *UpdateOperation_UpdateType   `protobuf:"varint,2,req,name=operation,enum=Mysqlx.Crud.UpdateOperation_UpdateType" json:"operation,omitempty"`
	Value            *Mysqlx_Expr.Expr             `protobuf:"bytes,3,opt,name=value" json:"value,omitempty"`
	XXX_unrecognized []byte                        `json:"-"`
}

func (m *UpdateOperation) Reset()                    { *m = UpdateOperation{} }
func (m *UpdateOperation) String() string            { return proto.CompactTextString(m) }
func (*UpdateOperation) ProtoMessage()               {}
func (*UpdateOperation) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *UpdateOperation) GetSource() *Mysqlx_Expr.ColumnIdentifier {
	if m != nil {
		return m.Source
	}
	return nil
}

func (m *UpdateOperation) GetOperation() UpdateOperation_UpdateType {
	if m != nil && m.Operation != nil {
		return *m.Operation
	}
	return UpdateOperation_SET
}

func (m *UpdateOperation) GetValue() *Mysqlx_Expr.Expr {
	if m != nil {
		return m.Value
	}
	return nil
}

// Find Documents/Rows in a Collection/Table
//
// .. uml::
//
//   client -> server: Find
//   ... one or more Resultset ...
//
// :param collection: collection to insert into
// :param data_model: datamodel that the operations refer to
// :param projection: list of column projections that shall be returned
// :param args: values for parameters used in filter expression
// :param criteria: filter criteria
// :param limit: numbers of rows that shall be skipped and returned
// :param order: sort-order in which the rows/document shall be returned in
// :param grouping: column expression list for aggregation (GROUP BY)
// :param grouping_criteria: filter criteria for aggregated groups
// :Returns: :protobuf:msg:`Mysqlx.Resultset::`
type Find struct {
	Collection       *Collection                `protobuf:"bytes,2,req,name=collection" json:"collection,omitempty"`
	DataModel        *DataModel                 `protobuf:"varint,3,opt,name=data_model,enum=Mysqlx.Crud.DataModel" json:"data_model,omitempty"`
	Projection       []*Projection              `protobuf:"bytes,4,rep,name=projection" json:"projection,omitempty"`
	Criteria         *Mysqlx_Expr.Expr          `protobuf:"bytes,5,opt,name=criteria" json:"criteria,omitempty"`
	Args             []*Mysqlx_Datatypes.Scalar `protobuf:"bytes,11,rep,name=args" json:"args,omitempty"`
	Limit            *Limit                     `protobuf:"bytes,6,opt,name=limit" json:"limit,omitempty"`
	Order            []*Order                   `protobuf:"bytes,7,rep,name=order" json:"order,omitempty"`
	Grouping         []*Mysqlx_Expr.Expr        `protobuf:"bytes,8,rep,name=grouping" json:"grouping,omitempty"`
	GroupingCriteria *Mysqlx_Expr.Expr          `protobuf:"bytes,9,opt,name=grouping_criteria" json:"grouping_criteria,omitempty"`
	XXX_unrecognized []byte                     `json:"-"`
}

func (m *Find) Reset()                    { *m = Find{} }
func (m *Find) String() string            { return proto.CompactTextString(m) }
func (*Find) ProtoMessage()               {}
func (*Find) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *Find) GetCollection() *Collection {
	if m != nil {
		return m.Collection
	}
	return nil
}

func (m *Find) GetDataModel() DataModel {
	if m != nil && m.DataModel != nil {
		return *m.DataModel
	}
	return DataModel_DOCUMENT
}

func (m *Find) GetProjection() []*Projection {
	if m != nil {
		return m.Projection
	}
	return nil
}

func (m *Find) GetCriteria() *Mysqlx_Expr.Expr {
	if m != nil {
		return m.Criteria
	}
	return nil
}

func (m *Find) GetArgs() []*Mysqlx_Datatypes.Scalar {
	if m != nil {
		return m.Args
	}
	return nil
}

func (m *Find) GetLimit() *Limit {
	if m != nil {
		return m.Limit
	}
	return nil
}

func (m *Find) GetOrder() []*Order {
	if m != nil {
		return m.Order
	}
	return nil
}

func (m *Find) GetGrouping() []*Mysqlx_Expr.Expr {
	if m != nil {
		return m.Grouping
	}
	return nil
}

func (m *Find) GetGroupingCriteria() *Mysqlx_Expr.Expr {
	if m != nil {
		return m.GroupingCriteria
	}
	return nil
}

// Insert documents/rows into a collection/table
//
// :param collection: collection to insert into
// :param data_model: datamodel that the operations refer to
// :param projection: name of the columns to insert data into (empty if data_model is DOCUMENT)
// :param row: set of rows to insert into the collection/table (a single expression with a JSON document literal or an OBJECT expression)
// :param args: values for parameters used in row expressions
// :Returns: :protobuf:msg:`Mysqlx.Resultset::`
type Insert struct {
	Collection       *Collection                `protobuf:"bytes,1,req,name=collection" json:"collection,omitempty"`
	DataModel        *DataModel                 `protobuf:"varint,2,opt,name=data_model,enum=Mysqlx.Crud.DataModel" json:"data_model,omitempty"`
	Projection       []*Column                  `protobuf:"bytes,3,rep,name=projection" json:"projection,omitempty"`
	Row              []*Insert_TypedRow         `protobuf:"bytes,4,rep,name=row" json:"row,omitempty"`
	Args             []*Mysqlx_Datatypes.Scalar `protobuf:"bytes,5,rep,name=args" json:"args,omitempty"`
	XXX_unrecognized []byte                     `json:"-"`
}

func (m *Insert) Reset()                    { *m = Insert{} }
func (m *Insert) String() string            { return proto.CompactTextString(m) }
func (*Insert) ProtoMessage()               {}
func (*Insert) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *Insert) GetCollection() *Collection {
	if m != nil {
		return m.Collection
	}
	return nil
}

func (m *Insert) GetDataModel() DataModel {
	if m != nil && m.DataModel != nil {
		return *m.DataModel
	}
	return DataModel_DOCUMENT
}

func (m *Insert) GetProjection() []*Column {
	if m != nil {
		return m.Projection
	}
	return nil
}

func (m *Insert) GetRow() []*Insert_TypedRow {
	if m != nil {
		return m.Row
	}
	return nil
}

func (m *Insert) GetArgs() []*Mysqlx_Datatypes.Scalar {
	if m != nil {
		return m.Args
	}
	return nil
}

type Insert_TypedRow struct {
	Field            []*Mysqlx_Expr.Expr `protobuf:"bytes,1,rep,name=field" json:"field,omitempty"`
	XXX_unrecognized []byte              `json:"-"`
}

func (m *Insert_TypedRow) Reset()                    { *m = Insert_TypedRow{} }
func (m *Insert_TypedRow) String() string            { return proto.CompactTextString(m) }
func (*Insert_TypedRow) ProtoMessage()               {}
func (*Insert_TypedRow) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7, 0} }

func (m *Insert_TypedRow) GetField() []*Mysqlx_Expr.Expr {
	if m != nil {
		return m.Field
	}
	return nil
}

// Update documents/rows in a collection/table
//
// :param collection: collection to change
// :param data_model: datamodel that the operations refer to
// :param criteria: filter expression to match rows that the operations will apply on
// :param args: values for parameters used in filter expression
// :param limit: limits the number of rows to match
// :param order: specifies order of matched rows
// :param operation: list of operations to be applied. Valid operations will depend on the data_model.
// :Returns: :protobuf:msg:`Mysqlx.Resultset::`
type Update struct {
	Collection       *Collection                `protobuf:"bytes,2,req,name=collection" json:"collection,omitempty"`
	DataModel        *DataModel                 `protobuf:"varint,3,opt,name=data_model,enum=Mysqlx.Crud.DataModel" json:"data_model,omitempty"`
	Criteria         *Mysqlx_Expr.Expr          `protobuf:"bytes,4,opt,name=criteria" json:"criteria,omitempty"`
	Args             []*Mysqlx_Datatypes.Scalar `protobuf:"bytes,8,rep,name=args" json:"args,omitempty"`
	Limit            *Limit                     `protobuf:"bytes,5,opt,name=limit" json:"limit,omitempty"`
	Order            []*Order                   `protobuf:"bytes,6,rep,name=order" json:"order,omitempty"`
	Operation        []*UpdateOperation         `protobuf:"bytes,7,rep,name=operation" json:"operation,omitempty"`
	XXX_unrecognized []byte                     `json:"-"`
}

func (m *Update) Reset()                    { *m = Update{} }
func (m *Update) String() string            { return proto.CompactTextString(m) }
func (*Update) ProtoMessage()               {}
func (*Update) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *Update) GetCollection() *Collection {
	if m != nil {
		return m.Collection
	}
	return nil
}

func (m *Update) GetDataModel() DataModel {
	if m != nil && m.DataModel != nil {
		return *m.DataModel
	}
	return DataModel_DOCUMENT
}

func (m *Update) GetCriteria() *Mysqlx_Expr.Expr {
	if m != nil {
		return m.Criteria
	}
	return nil
}

func (m *Update) GetArgs() []*Mysqlx_Datatypes.Scalar {
	if m != nil {
		return m.Args
	}
	return nil
}

func (m *Update) GetLimit() *Limit {
	if m != nil {
		return m.Limit
	}
	return nil
}

func (m *Update) GetOrder() []*Order {
	if m != nil {
		return m.Order
	}
	return nil
}

func (m *Update) GetOperation() []*UpdateOperation {
	if m != nil {
		return m.Operation
	}
	return nil
}

// Delete documents/rows from a Collection/Table
//
// :param collection: collection to change
// :param data_model: datamodel that the operations refer to
// :param criteria: filter expression to match rows that the operations will apply on
// :param args: values for parameters used in filter expression
// :param limit: limits the number of rows to match
// :param order: specifies order of matched rows
// :Returns: :protobuf:msg:`Mysqlx.Resultset::`
type Delete struct {
	Collection       *Collection                `protobuf:"bytes,1,req,name=collection" json:"collection,omitempty"`
	DataModel        *DataModel                 `protobuf:"varint,2,opt,name=data_model,enum=Mysqlx.Crud.DataModel" json:"data_model,omitempty"`
	Criteria         *Mysqlx_Expr.Expr          `protobuf:"bytes,3,opt,name=criteria" json:"criteria,omitempty"`
	Args             []*Mysqlx_Datatypes.Scalar `protobuf:"bytes,6,rep,name=args" json:"args,omitempty"`
	Limit            *Limit                     `protobuf:"bytes,4,opt,name=limit" json:"limit,omitempty"`
	Order            []*Order                   `protobuf:"bytes,5,rep,name=order" json:"order,omitempty"`
	XXX_unrecognized []byte                     `json:"-"`
}

func (m *Delete) Reset()                    { *m = Delete{} }
func (m *Delete) String() string            { return proto.CompactTextString(m) }
func (*Delete) ProtoMessage()               {}
func (*Delete) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *Delete) GetCollection() *Collection {
	if m != nil {
		return m.Collection
	}
	return nil
}

func (m *Delete) GetDataModel() DataModel {
	if m != nil && m.DataModel != nil {
		return *m.DataModel
	}
	return DataModel_DOCUMENT
}

func (m *Delete) GetCriteria() *Mysqlx_Expr.Expr {
	if m != nil {
		return m.Criteria
	}
	return nil
}

func (m *Delete) GetArgs() []*Mysqlx_Datatypes.Scalar {
	if m != nil {
		return m.Args
	}
	return nil
}

func (m *Delete) GetLimit() *Limit {
	if m != nil {
		return m.Limit
	}
	return nil
}

func (m *Delete) GetOrder() []*Order {
	if m != nil {
		return m.Order
	}
	return nil
}

func init() {
	proto.RegisterType((*Column)(nil), "Mysqlx.Crud.Column")
	proto.RegisterType((*Projection)(nil), "Mysqlx.Crud.Projection")
	proto.RegisterType((*Collection)(nil), "Mysqlx.Crud.Collection")
	proto.RegisterType((*Limit)(nil), "Mysqlx.Crud.Limit")
	proto.RegisterType((*Order)(nil), "Mysqlx.Crud.Order")
	proto.RegisterType((*UpdateOperation)(nil), "Mysqlx.Crud.UpdateOperation")
	proto.RegisterType((*Find)(nil), "Mysqlx.Crud.Find")
	proto.RegisterType((*Insert)(nil), "Mysqlx.Crud.Insert")
	proto.RegisterType((*Insert_TypedRow)(nil), "Mysqlx.Crud.Insert.TypedRow")
	proto.RegisterType((*Update)(nil), "Mysqlx.Crud.Update")
	proto.RegisterType((*Delete)(nil), "Mysqlx.Crud.Delete")
	proto.RegisterEnum("Mysqlx.Crud.DataModel", DataModel_name, DataModel_value)
	proto.RegisterEnum("Mysqlx.Crud.Order_Direction", Order_Direction_name, Order_Direction_value)
	proto.RegisterEnum("Mysqlx.Crud.UpdateOperation_UpdateType", UpdateOperation_UpdateType_name, UpdateOperation_UpdateType_value)
}

var fileDescriptor0 = []byte{
	// 778 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xb4, 0x55, 0xcd, 0x6e, 0xd3, 0x4a,
	0x14, 0x56, 0x1c, 0xdb, 0x49, 0x4e, 0xfa, 0x93, 0xf8, 0x4a, 0xbd, 0x56, 0xd5, 0xdb, 0x5b, 0x0c,
	0xa2, 0xa5, 0x14, 0x23, 0x45, 0x5d, 0x75, 0x81, 0x94, 0xc6, 0x06, 0x45, 0x6a, 0x9a, 0x28, 0x49,
	0x91, 0x10, 0x8b, 0xc8, 0xd8, 0x93, 0xd6, 0x95, 0xed, 0x31, 0x13, 0x9b, 0xb6, 0x2c, 0x78, 0x01,
	0xde, 0x80, 0x3d, 0x2f, 0x88, 0x78, 0x00, 0x66, 0xc6, 0x89, 0x1b, 0xa7, 0x49, 0x53, 0x24, 0xd8,
	0x58, 0xf6, 0x99, 0x6f, 0xce, 0x7c, 0xe7, 0x3b, 0xdf, 0x1c, 0x43, 0xd5, 0xbf, 0x19, 0x7d, 0xf4,
	0xae, 0x07, 0x36, 0x89, 0x1d, 0x3d, 0x24, 0x38, 0xc2, 0x4a, 0xb9, 0xc5, 0x43, 0x7a, 0x83, 0x86,
	0x36, 0x27, 0xeb, 0xe8, 0x3a, 0x24, 0xc9, 0xfa, 0xe6, 0xc6, 0x38, 0xe4, 0x58, 0x91, 0x15, 0xdd,
	0x84, 0x68, 0x94, 0xc4, 0xb5, 0xf7, 0x20, 0x37, 0xb0, 0x17, 0xfb, 0x81, 0xb2, 0x02, 0x62, 0x60,
	0xf9, 0x48, 0xcd, 0xed, 0xe4, 0xf6, 0x4a, 0xca, 0x2a, 0x48, 0x96, 0xe7, 0x5a, 0x23, 0x55, 0xe0,
	0x9f, 0x87, 0xb0, 0xea, 0x60, 0x3b, 0xf6, 0x51, 0x10, 0x0d, 0x42, 0x2b, 0xba, 0x50, 0xf3, 0x3b,
	0xf9, 0xbd, 0x72, 0xed, 0x3f, 0x7d, 0x7c, 0xac, 0xc9, 0x4e, 0x32, 0xc6, 0x88, 0x0e, 0x05, 0x34,
	0x23, 0xe4, 0x6b, 0xaf, 0x00, 0x3a, 0x04, 0x5f, 0x22, 0x3b, 0x72, 0x71, 0xa0, 0x3c, 0x02, 0x79,
	0x84, 0x63, 0x62, 0xb3, 0x23, 0x04, 0xba, 0xb9, 0x9a, 0xd9, 0xcc, 0x1e, 0x33, 0xa7, 0x6a, 0xfb,
	0x00, 0x94, 0x9c, 0x37, 0xde, 0x7f, 0x4b, 0x50, 0xa0, 0x8c, 0xd6, 0x68, 0x36, 0xfb, 0x02, 0xf9,
	0x56, 0x8a, 0x95, 0x4e, 0x5c, 0xdf, 0x8d, 0x94, 0x2a, 0x94, 0x08, 0xbe, 0x1a, 0xd8, 0x38, 0x0e,
	0x22, 0x8e, 0x15, 0x19, 0x16, 0x0f, 0x87, 0x23, 0x14, 0x71, 0xac, 0xa8, 0x7d, 0x01, 0xa9, 0x4d,
	0x1c, 0x44, 0x94, 0xff, 0x41, 0x64, 0x1a, 0x2d, 0x26, 0x74, 0x08, 0x25, 0xc7, 0x25, 0x09, 0x01,
	0xbe, 0x79, 0xad, 0xb6, 0xa5, 0x4f, 0x49, 0xad, 0xf3, 0x3c, 0xba, 0x31, 0xc1, 0x1c, 0xe5, 0xeb,
	0xbd, 0x86, 0xb6, 0x0d, 0xa5, 0x34, 0xa2, 0x14, 0x80, 0xc5, 0x2a, 0x39, 0xa5, 0x08, 0xa2, 0x61,
	0xd2, 0x37, 0x41, 0xfb, 0x26, 0xc0, 0xfa, 0x59, 0x48, 0x5b, 0x81, 0xda, 0x21, 0x22, 0x16, 0x87,
	0xbd, 0x98, 0x51, 0x27, 0x2b, 0x6d, 0xd2, 0xa3, 0xa6, 0x43, 0xd5, 0x75, 0x87, 0x2e, 0x65, 0x7e,
	0x04, 0x25, 0x3c, 0xd9, 0x4b, 0x89, 0x09, 0x94, 0xd8, 0x6e, 0x86, 0xd8, 0x4c, 0xfe, 0xf1, 0x77,
	0x9f, 0xb6, 0x5e, 0xd9, 0x01, 0xe9, 0x93, 0xe5, 0xc5, 0x88, 0x36, 0x31, 0x37, 0xb7, 0x6c, 0xed,
	0x33, 0xc0, 0x14, 0x9e, 0x56, 0xd0, 0x33, 0xfb, 0xb4, 0x82, 0x75, 0x28, 0x37, 0xfb, 0x66, 0x6b,
	0xd0, 0x35, 0x5b, 0xed, 0xb7, 0x66, 0x45, 0xa0, 0x2d, 0x29, 0xf2, 0x00, 0x5b, 0xce, 0x2b, 0x15,
	0x58, 0x19, 0x2f, 0x77, 0x4e, 0xea, 0x0d, 0xb3, 0xc2, 0x84, 0x07, 0x1e, 0x69, 0x99, 0xdd, 0x37,
	0x66, 0x45, 0x62, 0x88, 0x7a, 0xb7, 0x5b, 0x7f, 0x37, 0x68, 0x9e, 0xf6, 0xcc, 0x6e, 0xbf, 0x22,
	0xdf, 0x46, 0xea, 0x9d, 0x8e, 0x79, 0x6a, 0x54, 0x0a, 0xda, 0x0f, 0x01, 0xc4, 0xd7, 0x6e, 0xe0,
	0x28, 0xcf, 0x01, 0xec, 0xb4, 0xfb, 0xbc, 0xc6, 0x72, 0xed, 0xdf, 0x4c, 0x8d, 0x53, 0xe6, 0xa0,
	0x56, 0x61, 0xd6, 0x1e, 0xf8, 0xd8, 0x41, 0x1e, 0x2f, 0x6c, 0xad, 0xb6, 0x91, 0x01, 0x1b, 0x74,
	0xb9, 0xc5, 0x56, 0x59, 0xe2, 0x30, 0xb5, 0xa5, 0x2a, 0x72, 0x27, 0x67, 0x13, 0x4f, 0xb9, 0xf6,
	0x31, 0x14, 0x6d, 0xe2, 0x46, 0x88, 0xb8, 0x96, 0x2a, 0x2d, 0xd0, 0x4b, 0x79, 0x0a, 0xa2, 0x45,
	0xce, 0x47, 0x6a, 0x99, 0xe7, 0x52, 0x27, 0x00, 0x23, 0xbd, 0x6c, 0x3d, 0xdb, 0xf2, 0x2c, 0x42,
	0xaf, 0x80, 0xe4, 0x31, 0x93, 0xaa, 0x32, 0xcf, 0xa4, 0x64, 0x0e, 0x4d, 0xec, 0x4b, 0x21, 0x98,
	0x79, 0x4a, 0x2d, 0xf0, 0x5c, 0xca, 0x5d, 0xb7, 0x31, 0x4a, 0xe7, 0x04, 0xc7, 0xa1, 0x1b, 0x9c,
	0xab, 0x45, 0x8e, 0x9a, 0x43, 0xe9, 0x00, 0xaa, 0x13, 0xd0, 0x20, 0x2d, 0xa0, 0xb4, 0xa8, 0xe1,
	0x5f, 0x05, 0x90, 0x9b, 0xc1, 0x08, 0x91, 0x68, 0x46, 0xf6, 0xdc, 0xef, 0xc8, 0x2e, 0xdc, 0x2b,
	0xfb, 0x6e, 0x46, 0xf6, 0x64, 0x80, 0xfc, 0x33, 0x9b, 0x98, 0x4d, 0xa2, 0x67, 0x90, 0xa7, 0x37,
	0x78, 0xdc, 0x98, 0xec, 0x75, 0x4b, 0x38, 0xea, 0xcc, 0x96, 0x4e, 0x17, 0x5f, 0xa5, 0xc2, 0x4b,
	0xf7, 0x0b, 0xbf, 0x79, 0x00, 0xc5, 0x74, 0x0f, 0xb5, 0x3f, 0xbd, 0x42, 0x9e, 0x43, 0x6b, 0x9b,
	0xaf, 0x9d, 0xf6, 0x9d, 0xaa, 0x91, 0xf8, 0xff, 0xef, 0x99, 0x70, 0xda, 0x57, 0xe2, 0x32, 0x5f,
	0x15, 0x1f, 0xea, 0x2b, 0x69, 0xb9, 0xaf, 0xe4, 0x85, 0xbe, 0x7a, 0x39, 0x3d, 0x53, 0x0a, 0x73,
	0xd4, 0x9f, 0x99, 0x29, 0xda, 0xcf, 0x1c, 0xc8, 0x06, 0xf2, 0xd0, 0x1d, 0x9d, 0xfe, 0xa0, 0x6b,
	0xa6, 0x75, 0xca, 0x2f, 0xd3, 0x49, 0x7e, 0xa8, 0x4e, 0xe2, 0x72, 0x9d, 0xa4, 0x45, 0x3a, 0xed,
	0x3f, 0xa1, 0xe3, 0x3d, 0xe5, 0x47, 0x47, 0xa0, 0xd1, 0x6e, 0x9c, 0xb5, 0xcc, 0x53, 0x36, 0x21,
	0x4b, 0x20, 0xf5, 0xeb, 0xc7, 0x27, 0x74, 0x36, 0x1e, 0x6f, 0xc3, 0x96, 0x8d, 0x7d, 0x9d, 0xff,
	0x77, 0x75, 0xfb, 0x32, 0x79, 0xb9, 0x4e, 0x7e, 0xbb, 0x1f, 0xe2, 0xe1, 0xaf, 0x00, 0x00, 0x00,
	0xff, 0xff, 0x9f, 0xee, 0xea, 0x35, 0xc5, 0x07, 0x00, 0x00,
}
